full_input = """#.########################################################################################################################
#><^.^>v^<><^<>>>^<>><>v>^v<^>>^v<>>..<<><v<<>v>v>>^^v.v><>v>v^^v>>vv^<<v<>v^<v<.v<vvv<<v>>^vv.^vv>.>^..^v<<>^^<v<v^v^v<.#
#>>v^^v^><.<<.^v<v>.><>^<<>^v^<vvv><v<<<v^vv><vv>>>v^.>>^<>><^<><v>>>.^v^>.><>^^<v^>>>v>^.<>>v^^v^^^<<.^.<v>>^>><>.><<>v>#
#>>^<^>^^<<>^<<^v^^v^<<<^.<<^v><>.vvv^.^<v>^v>>v>^v<>><<>v<vv<^v<v^<^>><<<>>.v<^>vv.vv^v<^^<vv.><>^>.vv^v<>><<>vv^v><.>^<#
#>v<v^v<.>^.><<<<v>vv^^<^>v<^^^<<v<<v.^v<^>^v^<v<<<<v<v><.v^><<<^><.><..v>^^v<^<<v<^>^v<<>v^>>^^^^>v>>vv^<v.<v<v.>^^.>vv<#
#>>^<v>.<^<v>^<v.^^.v<v>>v>.>>.>v^<<<<<v^<^<<<>>^<^^v.<^><>><^<>>v<^v^>^v^.<v^>v<>^<<<<<^^^<v.<<v<v><.<..v.<v<v.<.^>v^^><#
#<^^^v<<v<.<^.^<<^>^>>><v^^.^v<v^^.vv^vvv^^>>^^.<^>v^v<^v<<>><.v><<>v>>v<<.^><^v<<>v.<^^^vv.<v^><>>.<vvv<v.>.>v<v<^^^<.v>#
#<<v<^^v>^>v><v>v^<<.^vv><>v^v<vv<vvv^^<<>>v>^.<..v>><<^vvv<>^v<<^.<^><.v><^<^v<v>.>^vv^^<<>v>>>.vv^<>v^>.<>.^><vvv^<<>^<#
#<<<v>^^<^<^v.><>^vv><^>v.v<>.<vv.>><^<^^<v.^v..^>>..v<^.>v>><^>vv^>>^<^.<.^v<>vv<<v.<<v><^^^v^>^v>^v>^.>>>v<>^vv>^^^^^^>#
#>>..><v><<>.^>>v>v^>><^<><^<<<vv>vv^v<vv<>.^vv.vvvv>>^^>^^<^>..><vvv^^<.^v^.<.^<<>^v<^^^<^><v^><^v^>>^><..>^>^>^<^.^<v<>#
#>^^..^v>v<^>>>><<.^^>^<><<><^^^><<>>^^><^^<<^v^^.<vv.vv<><>v.^<vv^v^v>^<<<.><vv^<.v^^v^^.>.>><..v<<^>v.^<.<<v>^<>.<.vvv<#
#<>>>>^^^vv^v<<<v.v^v>>v.<<^^.^^^>v<^>.<>^>.^v<<^<>^><>^<>^^.^<<v^^.><vv<^<><<.^<^>.^>v<>>>vv>^v^><^<<<>.>v>>^<>^^>^v<^v>#
#<><v^>>v>>^.^>>.<^v.>>><^^^><><>v^<<vvv><>v<<.^v>^>^v^>^^^><^^vv^^^<.<<v^v<><^^^<>v>^vv>>.v^>.^<v<>.>><<v^v<<^>^.v<v.<<>#
#<v<^^><<<>vvvvv<^^v<>^v.>vv<<>^<<>>>><>>>.vv>>^^v^>^<^>v^v^.^^<v^^>^.<><vvv.v.v><<<>><><>v<<<>^^><v^<.v>v<>^.>>v^<v^v<^<#
#>^^v>.<v<.v>^^v^<<>v>>.^>^>vv><v<><<^<>^v><.^<<<vvv.>>>.<^.^^>^^v<<>^>^<^><<^^^^vv^>><>>>><.<vvv^>>v.vv^..^<v.><vv>v>>.<#
#>^>^<v^v<vvv<^v^^<^<<>><..^^v<<v<>v>v.^<<<^v^^><v>>>^.^^^vv<^^><^.v^.>^><<.<<.<>^vvv<^>^<<v<.>v>^vvvvvv^^.^><>.>>.><..><#
#>><>^^>.>^^^^>>v<v<><^><>>>^^^^>^.>^^>>.<<v>v>>>v<<>><v><^.v^v^v>><>v<v<^^<.>>>^<^^vvv.>v^<>^>^v<v^>v>.><v^^^v>^v>>v^^<>#
#><<><<v.v^^>.vvvv>>^^>vv>.<^v.>.vv^v^..vvv^^>>v^^vvvvv<<v>.<^<>vv>><^<>v>.<>v.^>^<.>^^<^.>^<<v^v.<.>vv^^<.^vv>v<vv<.>^^>#
#><>^v<^vv>^.<^v<v>^<v.vv<<^v<v^^>^^>><<<v<<v^.vv><<>>v^<^>>>><<.vvv<v^v>^<^>v>^^^.^^>v<^v^v^^<<<><^<v<^^v><v>>vv<vv>>>^>#
#<^vv<<vv>.<>>^>v^vv^v<^v<vv<vv>^v.<v<^>>^>v>>>v^>.>^>v.<<<v.^>vv^.<>v<vv<><^^^>.>>>^v^^v<v^v>^>^vvv>>v^v^>>v^^^<><v>^>>>#
#>>><<^<.<v.v>>.v^<><<>>^v.>vvv^<v><vv>^<^v<<>.^<<v.vv<^^^><>^>>v>^vv^<<><>>^vvvv<<v<v><.^^^>^<>>v>.^<>.<v<<v<>^v^^^<v>v.#
#><^^>>><v.^><>>.^v^<<.>v<<<...<<^<>.v><vv>.<<.>^^>^.^<v^<>^>^>^v<v<.^v<<vvv^v.^.><v<v<v.v><<^v<<><>^<vvv.<><><v>.<v^^<.>#
#<><>^<<>v.^<.vvvvv<v^<^>^<^.>v>>.<^^vv^v.^<>^<>>v.^v<>v^^.>^^v>^<^<^<^<<<v<^<^^>>^^>^<.v<<>v<.^.<v><.>^<^^v>^>>.^^.^v^>>#
#>>.><^vv^><<>>v<v<><v<>^<^><vvv>.>^>>^.>^>v<>^<<<><..<>>.<v.<>^.v^^<<^^<>vvv<^v><><<<^>>v><<>.<v>>>^^>>.>><v^<^^^>v..v><#
#><vv<>.><<>^<v^^^>^.^^><^>>>^v<>vv<<^v<v>v.>>v^vv^<<v^v<^<.v^v>v.vv^>vv.>.<<<>^>^v.>v<v<^<^vv>vv^^<>>..v.>^><v<<vv^>v..<#
#><v>>>vvv<<<>>><^>^^>v<<v>^.><v<>^v><^<.v<v^<v<>^^><v.vv<..<>><>^v<<><<.^^v<>^<<><<.><v<>^<v.^<v^^^...>><>>^^^.>v^v^>vv>#
########################################################################################################################.#"""

test_input = """#.######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#"""

class Blizzard:
    def __init__(self, row, col, dir_str):
        self.row = row
        self.col = col
        self.dir_str = dir_str
        if dir_str == '>':
            self.drow = 0
            self.dcol = 1
        elif dir_str == '<':
            self.drow = 0
            self.dcol = -1
        elif dir_str == '^':
            self.drow = -1
            self.dcol = 0
        elif dir_str == 'v':
            self.drow = 1
            self.dcol = 0
        else:
            raise Exception(f'Bad direction string for wind: {dir_str}')
    
    def __str__(self):
        return self.dir_str
        
    def move(self,right, bottom, left, top, reverse=False):
        if reverse:
            self.row -= self.drow
            self.col -= self.dcol
        else:
            self.row += self.drow
            self.col += self.dcol
        if self.row <= top:
            self.row = bottom - 1
        elif self.row >= bottom:
            self.row = top + 1
        elif self.col <= left:
            self.col = right - 1
        elif self.col >= right:
            self.col = left + 1
    
    # TODO: Figure out if these should just be tuples the entire time?        
    def get_tuple(self):
        return (self.row, self.col, self.dir_str)
            
class Valley:
    
    def __init__(self, input_str):
        lines = input_str.split('\n')
        self.top = 0
        self.left = 0
        self.bottom = len(lines) - 1
        self.right = len(lines[0]) - 1
        self.grid = [[[] for _ in range(self.right+1)] for _ in range(self.bottom+1)]
        self.blizzards = []
        for row, line in enumerate(lines):
            for col, char in enumerate(line):
                if char in ['>', 'v', '<', '^']:
                    bliz = Blizzard(row, col, char)
                    self.grid[row][col].append(bliz)
                    self.blizzards.append(bliz)
        self.explorer = (0,1)
        self.states = dict()
        
    def __str__(self):
        result_str = ''
        for irow, row in enumerate(self.grid):
            for icol, bliz_list in enumerate(row):
                if irow == self.explorer[0] and icol == self.explorer[1]:
                    result_str += 'E'
                elif (irow == self.top and icol == self.left + 1) or (irow == self.bottom and icol == self.right - 1):
                    result_str += '.'
                elif irow == self.top or irow == self.bottom or icol == self.left or icol == self.right:
                    result_str += '#'
                elif len(bliz_list) > 1:
                    result_str += str(len(bliz_list))
                elif len(bliz_list) == 1:
                    result_str += str(bliz_list[0])
                else:
                    result_str += '.'
            result_str += '\n'
        return result_str
        
    def get_state(self):
        return tuple([bliz.get_tuple() for bliz in self.blizzards] + [self.explorer])
        
    def move_blizzards(self, reverse=False):
        for bliz in self.blizzards:
            self.grid[bliz.row][bliz.col].remove(bliz)
            bliz.move(self.right, self.bottom, self.left, self.top, reverse=reverse)
            self.grid[bliz.row][bliz.col].append(bliz)
            
    def explore(self, path_length=0, best_above=999999, verbose=False):
        if verbose:
            print(self)
            input()
        # -1. Check if we have reached the end
        if self.explorer == (self.bottom-1, self.right-1):
            return path_length + 1
        # 0. Check if we have seen this state before at this time or less. If we have,
        #    ignore this, if we haven't, add this state to the explored
        state = self.get_state()
        if state in self.states and self.states[state] <= path_length:
            return 999999
        else:
            self.states[state] = path_length
        # 0a. Also check if the current distance from the finish is longer than the
        #     shortest path found so far. If it is, we can ignore this branch
        distance_to_finish = abs(self.bottom - self.explorer[0]) + abs((self.right - 1) - self.explorer[1])
        if distance_to_finish >= best_above:
            return 999999
        # TODO
        # 1. Move the blizzards
        self.move_blizzards()
        # 2. Get the valid spots that we can move to
        to_explore = []
        for (drow, dcol) in [(1,0), (0,1), (0,0), (-1,0), (0,-1)]:
            new_row = self.explorer[0] + drow
            new_col = self.explorer[1] + dcol
            if (new_row, new_col) == (0,1) or (self.top < new_row < self.bottom and 
                self.left < new_col < self.right and 
                len(self.grid[new_row][new_col]) == 0):
                to_explore.append((new_row, new_col))
        # 3. Sort the spots by how close they are to the exit
        #   - Because the exit is always in the bottom right, we can actually skip this.
        #     the options will always be sorted already since we start with the two that
        #     get closer and end with the two that get further away.
        # 4. Explore the now-sorted options
        cur_explorer = self.explorer
        best = 999999
        for next_explorer in to_explore:
            self.explorer = next_explorer
            pl = self.explore(path_length + 1, min(best_above, best), verbose=verbose)
            best = min(pl, best)
        # 5. Reverse the blizzards and reset the explorer
        self.move_blizzards(reverse=True)
        self.explorer = cur_explorer
        return best
        
def part_1(input_str, verbose=False):
    valley = Valley(input_str)
    return valley.explore(verbose=verbose)
        
print(part_1(test_input))
print(part_1(full_input))
