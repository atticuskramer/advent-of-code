full_input = """#.########################################################################################################################
#><^.^>v^<><^<>>>^<>><>v>^v<^>>^v<>>..<<><v<<>v>v>>^^v.v><>v>v^^v>>vv^<<v<>v^<v<.v<vvv<<v>>^vv.^vv>.>^..^v<<>^^<v<v^v^v<.#
#>>v^^v^><.<<.^v<v>.><>^<<>^v^<vvv><v<<<v^vv><vv>>>v^.>>^<>><^<><v>>>.^v^>.><>^^<v^>>>v>^.<>>v^^v^^^<<.^.<v>>^>><>.><<>v>#
#>>^<^>^^<<>^<<^v^^v^<<<^.<<^v><>.vvv^.^<v>^v>>v>^v<>><<>v<vv<^v<v^<^>><<<>>.v<^>vv.vv^v<^^<vv.><>^>.vv^v<>><<>vv^v><.>^<#
#>v<v^v<.>^.><<<<v>vv^^<^>v<^^^<<v<<v.^v<^>^v^<v<<<<v<v><.v^><<<^><.><..v>^^v<^<<v<^>^v<<>v^>>^^^^>v>>vv^<v.<v<v.>^^.>vv<#
#>>^<v>.<^<v>^<v.^^.v<v>>v>.>>.>v^<<<<<v^<^<<<>>^<^^v.<^><>><^<>>v<^v^>^v^.<v^>v<>^<<<<<^^^<v.<<v<v><.<..v.<v<v.<.^>v^^><#
#<^^^v<<v<.<^.^<<^>^>>><v^^.^v<v^^.vv^vvv^^>>^^.<^>v^v<^v<<>><.v><<>v>>v<<.^><^v<<>v.<^^^vv.<v^><>>.<vvv<v.>.>v<v<^^^<.v>#
#<<v<^^v>^>v><v>v^<<.^vv><>v^v<vv<vvv^^<<>>v>^.<..v>><<^vvv<>^v<<^.<^><.v><^<^v<v>.>^vv^^<<>v>>>.vv^<>v^>.<>.^><vvv^<<>^<#
#<<<v>^^<^<^v.><>^vv><^>v.v<>.<vv.>><^<^^<v.^v..^>>..v<^.>v>><^>vv^>>^<^.<.^v<>vv<<v.<<v><^^^v^>^v>^v>^.>>>v<>^vv>^^^^^^>#
#>>..><v><<>.^>>v>v^>><^<><^<<<vv>vv^v<vv<>.^vv.vvvv>>^^>^^<^>..><vvv^^<.^v^.<.^<<>^v<^^^<^><v^><^v^>>^><..>^>^>^<^.^<v<>#
#>^^..^v>v<^>>>><<.^^>^<><<><^^^><<>>^^><^^<<^v^^.<vv.vv<><>v.^<vv^v^v>^<<<.><vv^<.v^^v^^.>.>><..v<<^>v.^<.<<v>^<>.<.vvv<#
#<>>>>^^^vv^v<<<v.v^v>>v.<<^^.^^^>v<^>.<>^>.^v<<^<>^><>^<>^^.^<<v^^.><vv<^<><<.^<^>.^>v<>>>vv>^v^><^<<<>.>v>>^<>^^>^v<^v>#
#<><v^>>v>>^.^>>.<^v.>>><^^^><><>v^<<vvv><>v<<.^v>^>^v^>^^^><^^vv^^^<.<<v^v<><^^^<>v>^vv>>.v^>.^<v<>.>><<v^v<<^>^.v<v.<<>#
#<v<^^><<<>vvvvv<^^v<>^v.>vv<<>^<<>>>><>>>.vv>>^^v^>^<^>v^v^.^^<v^^>^.<><vvv.v.v><<<>><><>v<<<>^^><v^<.v>v<>^.>>v^<v^v<^<#
#>^^v>.<v<.v>^^v^<<>v>>.^>^>vv><v<><<^<>^v><.^<<<vvv.>>>.<^.^^>^^v<<>^>^<^><<^^^^vv^>><>>>><.<vvv^>>v.vv^..^<v.><vv>v>>.<#
#>^>^<v^v<vvv<^v^^<^<<>><..^^v<<v<>v>v.^<<<^v^^><v>>>^.^^^vv<^^><^.v^.>^><<.<<.<>^vvv<^>^<<v<.>v>^vvvvvv^^.^><>.>>.><..><#
#>><>^^>.>^^^^>>v<v<><^><>>>^^^^>^.>^^>>.<<v>v>>>v<<>><v><^.v^v^v>><>v<v<^^<.>>>^<^^vvv.>v^<>^>^v<v^>v>.><v^^^v>^v>>v^^<>#
#><<><<v.v^^>.vvvv>>^^>vv>.<^v.>.vv^v^..vvv^^>>v^^vvvvv<<v>.<^<>vv>><^<>v>.<>v.^>^<.>^^<^.>^<<v^v.<.>vv^^<.^vv>v<vv<.>^^>#
#><>^v<^vv>^.<^v<v>^<v.vv<<^v<v^^>^^>><<<v<<v^.vv><<>>v^<^>>>><<.vvv<v^v>^<^>v>^^^.^^>v<^v^v^^<<<><^<v<^^v><v>>vv<vv>>>^>#
#<^vv<<vv>.<>>^>v^vv^v<^v<vv<vv>^v.<v<^>>^>v>>>v^>.>^>v.<<<v.^>vv^.<>v<vv<><^^^>.>>>^v^^v<v^v>^>^vvv>>v^v^>>v^^^<><v>^>>>#
#>>><<^<.<v.v>>.v^<><<>>^v.>vvv^<v><vv>^<^v<<>.^<<v.vv<^^^><>^>>v>^vv^<<><>>^vvvv<<v<v><.^^^>^<>>v>.^<>.<v<<v<>^v^^^<v>v.#
#><^^>>><v.^><>>.^v^<<.>v<<<...<<^<>.v><vv>.<<.>^^>^.^<v^<>^>^>^v<v<.^v<<vvv^v.^.><v<v<v.v><<^v<<><>^<vvv.<><><v>.<v^^<.>#
#<><>^<<>v.^<.vvvvv<v^<^>^<^.>v>>.<^^vv^v.^<>^<>>v.^v<>v^^.>^^v>^<^<^<^<<<v<^<^^>>^^>^<.v<<>v<.^.<v><.>^<^^v>^>>.^^.^v^>>#
#>>.><^vv^><<>>v<v<><v<>^<^><vvv>.>^>>^.>^>v<>^<<<><..<>>.<v.<>^.v^^<<^^<>vvv<^v><><<<^>>v><<>.<v>>>^^>>.>><v^<^^^>v..v><#
#><vv<>.><<>^<v^^^>^.^^><^>>>^v<>vv<<^v<v>v.>>v^vv^<<v^v<^<.v^v>v.vv^>vv.>.<<<>^>^v.>v<v<^<^vv>vv^^<>>..v.>^><v<<vv^>v..<#
#><v>>>vvv<<<>>><^>^^>v<<v>^.><v<>^v><^<.v<v^<v<>^^><v.vv<..<>><>^v<<><<.^^v<>^<<><<.><v<>^<v.^<v^^^...>><>>^^^.>v^v^>vv>#
########################################################################################################################.#"""

test_input = """#.######
#>>.<^<#
#.<..<<#
#>v.><>#
#<^v^^>#
######.#"""

from queue import deque

class Blizzard:
    def __init__(self, row, col, dir_str, drow=None, dcol=None):
        self.row = row
        self.col = col
        self.dir_str = dir_str
        if drow is None or dcol is None:
            if dir_str == '>':
                self.drow = 0
                self.dcol = 1
            elif dir_str == '<':
                self.drow = 0
                self.dcol = -1
            elif dir_str == '^':
                self.drow = -1
                self.dcol = 0
            elif dir_str == 'v':
                self.drow = 1
                self.dcol = 0
            else:
                raise Exception(f'Bad direction string for wind: {dir_str}')
        else:
            self.drow = drow
            self.dcol = dcol
    
    def __str__(self):
        return self.dir_str
            
    def moved(self, moves, right, bottom, left, top):
        new_row = self.row + self.drow * moves
        new_col = self.col + self.dcol * moves
        new_row = top + (new_row % (bottom - top - 1))
        new_col = left + (new_col % (right - left - 1))
        if new_row == top:
            new_row = bottom - 1
        if new_row == left:
            new_row = right - 1
        return Blizzard(new_row, new_col, self.dir_str, self.drow, self.dcol)
            
class Valley:
    
    def __init__(self, input_str):
        lines = input_str.split('\n')
        self.top = 0
        self.left = 0
        self.bottom = len(lines) - 1
        self.right = len(lines[0]) - 1
        self.start = (self.top, self.left + 1)
        self.goal = (self.bottom, self.right - 1)
        self.blizzards = []
        for row, line in enumerate(lines):
            for col, char in enumerate(line):
                if char in ['>', 'v', '<', '^']:
                    bliz = Blizzard(row, col, char)
                    self.blizzards.append(bliz)
        self.explorer = self.start
        # This is a janky way to bootstrap this into existence
        self.blizzard_positions = []
        self.blizzard_positions.append(self.blizzards_after(0))
        
    # def __str__(self):
    #     result_str = ''
    #     for irow, row in enumerate(self.grid):
    #         for icol, bliz_list in enumerate(row):
    #             if irow == self.explorer[0] and icol == self.explorer[1]:
    #                 result_str += 'E'
    #             elif (irow == self.top and icol == self.left + 1) or (irow == self.bottom and icol == self.right - 1):
    #                 result_str += '.'
    #             elif irow == self.top or irow == self.bottom or icol == self.left or icol == self.right:
    #                 result_str += '#'
    #             elif len(bliz_list) > 1:
    #                 result_str += str(len(bliz_list))
    #             elif len(bliz_list) == 1:
    #                 result_str += str(bliz_list[0])
    #             else:
    #                 result_str += '.'
    #         result_str += '\n'
    #     return result_str
    
    def print_state(self, state):
        new_blizzards = self.blizzards_after(state[0])
        explorer = state[1:]
        result_str = f'Path length: {state[0]}\n'
        for row in range(self.bottom + 1):
            for col in range(self.right + 1):
                if (row, col) == explorer:
                    result_str += 'E'
                elif (row, col) == self.start or (row, col) == self.goal:
                    result_str += '.'
                elif row == self.bottom or row == self.top or col == self.left or col == self.right:
                    result_str += '#'
                elif (row, col) in new_blizzards and len(new_blizzards[(row,col)]) == 1:
                    result_str += new_blizzards[(row, col)]
                elif (row, col) in new_blizzards:
                    result_str += str(len(new_blizzards[(row, col)]))
                else:
                    result_str += '.'
            result_str += '\n'
        print(result_str)
    
    def blizzards_after(self, time):
        if len(self.blizzard_positions) > time:
            return self.blizzard_positions[time]
        else:
            assert len(self.blizzard_positions) == time
        bliz_dict = {}
        for bliz in self.blizzards:
            moved = bliz.moved(time, self.right, self.bottom, self.left, self.top)
            location = (moved.row, moved.col)
            if location in bliz_dict:
                bliz_dict[location] += moved.dir_str
            else:
                bliz_dict[location] = bliz.dir_str
        self.blizzard_positions.append(bliz_dict)
        return bliz_dict
        
    def is_goal(self, state):
        return state[1:] == self.goal
    
    def get_next_states(self, state):
        next_path_length = state[0] + 1
        new_blizzards = self.blizzards_after(next_path_length)
        next_states = []
        for (drow, dcol) in [(1,0), (0,1), (0,0), (-1,0), (0,-1)]:
            new_row = state[1] + drow
            new_col = state[2] + dcol
            if ((new_row, new_col) == self.start or 
                (new_row, new_col) == self.goal or 
                (self.top < new_row < self.bottom and 
                self.left < new_col < self.right and 
                (new_row, new_col) not in new_blizzards)):
                next_states.append((next_path_length, new_row, new_col))
        return next_states
    
    def get_f_score(self, state):
        return state[0] + abs(state[1] - self.goal[0]) + abs(state[2] - self.goal[1])
        
def a_star_explore(valley):
    # 0. Keep track of a set of explored states, and a queue of next states, both starting
    #    with just the initial state.
    # Our state will just be a triple of (path_length, explorer_row, explorer_col)
    start_state = (0, valley.start[0], valley.start[1])
    queue = deque([start_state])
    explored = set(queue)
    # While there are states to check left in the queue...
    while(queue):
        # 1. Pop the first item in the queue and set that to be our current state
        cur_state = queue.popleft()
        valley.print_state(cur_state)
        # 2. Check if the current state is the goal state, if it is, return the path(_length)
        #    from the start state to the goal
        if valley.is_goal(cur_state):
            return cur_state[0]
        # 3. Get all of the next possible states from the current state that are not already
        #    in our set of explored states
        next_states = [state for state in valley.get_next_states(cur_state) if state not in explored]
        # 4. Insert those states into the queue, keeping the queue sorted based on increasing
        #    f score, where f(state) = length from start to state + manhattan distance to goal state
        for state in next_states:
            inserted = False
            for i, q_state in enumerate(queue):
                if valley.get_f_score(state) < valley.get_f_score(q_state):
                    queue.insert(i, state)
                    inserted = True
                    break
            if not inserted:
                queue.append(state)
            explored.add(state)
    # 5. If we break out of the loop, then there is no path from the start to the goal
    return -1
        
def part_1(input_str, verbose=False):
    valley = Valley(input_str)
    # for i in range(10):
    #     print(valley.blizzards_after(i))
    return a_star_explore(valley)
        
print(part_1(test_input))

# print(part_1(full_input))